# Zajęcia 08

## Konfiguracja maszyny zdalnej 

![img](./img/image32.png)

![img](./img/image45.png)

Utworzenie migawki maszyny

![alt text](./img/1.png)

Instalacja Ansible

![img](./img/image11.png)

## Kuminikacja między maszynami poprzez SSH

![img](./img/image34.png)

Generowanie klucza SSH i test połączenia

![img](./img/image35.png)

![img](./img/image37.png)

Wprowadzenie nazw DNS dla maszyn

![img](./img/image25.png)

![img](./img/image9.png)

## Utworzenie i uruchomienie ansible playbooka

Test pliu `.ini`

![img](./img/image14.png)

Wykonanie zdefiniowanych czynności za pomocą playbooka

    - name: 1. Ping all hosts
    hosts: Endpoints
    gather_facts: no
    tasks:
        - name: Ping test
        ansible.builtin.ping:

    - name: 2. Copy inventory to endpoints
    hosts: Endpoints
    gather_facts: no
    tasks:
        - name: Copy inventory.ini to /tmp
        ansible.builtin.copy:
            src: ./inventory.ini
            dest: /tmp/inventory.ini

    - name: 3. Update system packages
    hosts: Endpoints
    become: yes
    tasks:
        - name: Update all packages
        ansible.builtin.dnf:
            name: "*"
            state: latest

    - name: 4. Restart services
    hosts: Endpoints
    become: true
    tasks:
        - name: Restart sshd
        ansible.builtin.service:
            name: sshd
            state: restarted

        - name: Restart rngd
        ansible.builtin.service:
            name: rngd
            state: restarted
            enabled: true

![alt text](./img/2.png) 

Uruchomienie aplikacji powstałej z artefaktu z playbooka z wykorzystaniem `ansible-galaxy`

![alt text](./img/3.png) 

![alt text](./img/4.png)

# Zajęcia 09

## Wyodrębnienie i przeprowadzenie instalacji za pomocą pliku kicktart

![img](./img/image43.png)

Dodanie repozytoriów i wykonanie instalacji 

    # Generated by Anaconda 41.35
    # Generated by pykickstart v3.58
    #version=DEVEL

    # Keyboard layouts
    keyboard --vckeymap=pl --xlayouts='pl'
    # System language
    lang pl_PL.UTF-8

    # Network information
    network  --bootproto=dhcp --device=enp0s3 --ipv6=auto --activate --hostname=fedora-server

    %packages
    @^server-product-environment

    %end

    # Run the Setup Agent on first boot
    firstboot --enable

    # Repos
    url --mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-41&arch=x86_64
    repo --name=update --mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=updates-released-f41&arch=x86_64

    # Generated using Blivet version 3.11.0
    ignoredisk --only-use=sda
    autopart
    # Partition clearing information
    clearpart --all

    # System timezone
    timezone Europe/Warsaw --utc

    # Root password
    rootpw --iscrypted --allow-ssh $y$j9T$Pn5OIqlK3DDm0LYXfIuqbSAF$IfAFKMGeIBtuxRf3.bHdSaTb9vGO2olpI2mSL3EOy.8
    user --groups=wheel --name=azakrecka --password=$y$j9T$Jl7PoImDsug.iY7YqcZg33BK$pd.7W7IGljtNjo5ImnqcvKsUYotHJo0xlE5.DybtL30 --iscrypted --gecos="Aleksandra Zakrecka"

    reboot
![img](./img/image18.png)

![img](./img/image46.png)

## Utworzenie własnego repozytorium w celu udostępnienia artefaktu

Utwożenie maszyny WSL w celu udostępniania repozytorium 

![img](./img/image6.png)

![img](./img/image5.png)

Przesłanie artefaktu na maszyne

![img](./img/image8.png)

Weryfikacja działania

![img](./img/image41.png)

Udostępnianie portu i test działania

![img](./img/image24.png)

![img](./img/image22.png)

![image23.png](./img/image23.png)

## Przeprowadzenioe instalacji zawierajacej artefakt

Dodanie sekcji `%post` do pliku kicksart odpowiedzialnego za instalacjie artefaktu

    %packages
    @^server-product-environment
    redis-20250427203018-1.fc42.x86_64
    %end

    %post --log=/root/post-install.log

    cat <<EOF > /etc/systemd/system/redis.service
    [Unit]
    Description=Redis In-Memory Data Store
    After=network.target

    [Service]
    ExecStart=/usr/local/bin/redis-server
    Restart=always
    User=root
    Group=root

    [Install]
    WantedBy=multi-user.target
    EOF

    systemctl daemon-reexec
    systemctl daemon-reload
    systemctl enable redis

    %end

Test działania

![image42.png](./img/image42.png)

# Zajęcia 10

## Instalacja i konfiguracja kubernesta

![image33.png](./img/image33.png)

![image36.png](./img/image36.png)

![image2.png](./img/image2.png)

![image44.png](./img/image44.png)

## Utworzenie obrazu aplikacji z własnymi ustawieniami 

Wykorzystanie obrazu aplikacji Redis i dodanie do niego własnych ustawień  

![image4.png](./img/image4.png)

![image21.png](./img/image21.png)

Test zbudowaniego obrazu 

    docker run -d --name my-custom-redis -p 6379:6379 custom-redis

![image3.png](./img/image3.png)

![image39.png](./img/image39.png)

![image28.png](./img/image28.png)

## Załadowanie obrazu i uruchomienie Poda

![image30.png](./img/image30.png)

    minikube kubectl -- run custom-redis-pod --image=custom-redis --port=6379 --labels app=custom-redis --image-pull-policy=Never

![image27.png](./img/image27.png)

## Przekierowanie portów i test działania 

    kubectl port-forward pod/custom-redis-pod 6379:6379

![image31.png](./img/image31.png)

![image7.png](./img/image7.png)

![image16.png](./img/image16.png)

![image15.png](./img/image15.png)

## Utworzenie Deploymentu z obrazu 

    kubectl create deployment custom-redis   --image=custom-redis   --dry-run=client -o yaml > redis-deploy.yaml

![image20.png](./img/image20.png)

Ustawienie odpowieniej liczby podów

    spec:
    replicas: 5
    selector:
        matchLabels:
        app: custom-redis
    template:
        metadata:
        creationTimestamp: null
        labels:
            app: custom-redis
        spec:
        containers:
            - name: custom-redis
            image: custom-redis
            resources: {}
            terminationMessagePath: /dev/termination-log
            terminationMessagePolicy: File
            imagePullPolicy: Never
        restartPolicy: Always
        terminationGracePeriodSeconds: 30
        dnsPolicy: ClusterFirst
        securityContext: {}
        schedulerName: default-scheduler

![image1.png](./img/image1.png)

![image29.png](./img/image29.png)

![image26.png](./img/image26.png)

## Przekierowanie portów i test działania 

Eksponowanie kontenera z Deploymentu poprzez wykorzystanie serwisu

![image40.png](./img/image40.png)

Test połączenia spoza kastra minikube

![image12.png](./img/image12.png)

Przekierowanie portu w celu udostępnienia go dla localhost

![image17.png](./img/image17.png)

![image19.png](./img/image19.png)

Przekierowanie portu w celu udostępnienia go poza maszynę wirtualną 

![image38.png](./img/image38.png)

![image13.png](./img/image13.png)

# Zajęcia 11

## Przygotowanie nowych wersji obrazu

![alt text](./img/image022.png)

![alt text](./img/image014.png)

![alt text](./img/image025.png)

Test wadliwego kontenera

![alt text](./img/image04.png)

Import utwożonych kontenerów do minikubea

    minikube image load redis-custom:vx

![alt text](./img/image019.png)

## Przeprowadzanie zmian w deploy

Zwiększenie replik do 8

![alt text](./img/image021.png)

Zmniejszenie replik do 1 

![alt text](./img/image100.png)

Zmniejszenie replik do 0 

![alt text](./img/image06.png)

Ponowne zwiększenie ilości replik 

![alt text](./img/image023.png)

Wprowadzenie nowego obrazu

![alt text](./img/image011.png)

![alt text](./img/image03.png)

Wprowadzenie wadliwego obrazu

![alt text](./img/image08.png)

## Przywracanie poprzedniej wersji wadliwego obrazu

![alt text](./img/image018.png)

![alt text](./img/image09.png)

## Monitorowanie wdrożenia

![alt text](./img/image024.png)

Napisanie własnego skryptu monitorującego 

![alt text](./img/image020.png)

![alt text](./img/image05.png)

## Strategie wdrożenia 

 Strategia Recreate, czyli takia, w której stara wersja aplikacji zostaje całkowicie usunięta przed uruchomieniem nowej. Zastosowanie tej strategii skutkuje tym, że w żadnym momencie nie działają równocześnie stare i nowe pody. Przez krótki okres, żaden z podów nie jest aktywny, co oznacza, że usługa Redis jest chwilowo niedostępna.

![alt text](./img/image015.png)

![alt text](./img/image013.png)

W przeciwieństwie do strategii Recreate, w której najpierw usuwa się wszystkie stare instancje, tutaj w strategii RollingUpdate nowe pody są uruchamiane równolegle z istniejącymi. Parametry widoczne na zrzucie ekranu informują o maksymalnej ilości niedostepnych podów jednoczenieśnie (tutaj 2) i o ilczbie tymczasowo uruchomionych podów (tutaj 30%)

![alt text](./img/image016.png)

![alt text](./img/image07.png)

Wdrożenie realizowane w modelu Canary Deployment, tkieruje tylko część użytkowników do nowej wersji aplikacji, a reszta nadal obsługiwana jest przez wersję stabilną. W tym przypadku wykorzystano dwa oddzielne Deploymenty. Wykorzystano odpwiednie polecenia służące do przefiltrowania logów i sprawdzenia, które pody obsłużyły przychodzące żądania. W przypadku wykrycia błędów (np. w logach lub monitoringu) strategia pozwala na szybkie wycofanie tej wersji bez wpływu na większość użytkowników, którzy nadal korzystają z wersji stabilnej.

![alt text](./img/image02.png)

![alt text](./img/image2-1.png)

![alt text](./img/image01.png)