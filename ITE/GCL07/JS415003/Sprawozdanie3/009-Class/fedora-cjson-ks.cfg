# Fedora Kickstart Configuration for Unattended Installation
# Modified for cJSON Pipeline Deployment
#version=DEVEL

# System language
lang en_GB.UTF-8

# Keyboard layouts
keyboard --vckeymap=uk --xlayouts='gb','pl'

# Network information - VirtualBox typically uses enp0s3
network --bootproto=dhcp --device=enp0s3 --onboot=on --ipv6=auto --activate
network --hostname=fedora-cjson-server

# Use network installation sources
url --mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-41&arch=x86_64
repo --name=updates --mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=updates-released-f41&arch=x86_64

# System authorization information
auth --enableshadow --passalgo=sha512

# Root password (change this for production!)
rootpw --iscrypted $y$j9T$XivJoeqr.DbiQ0w4fsCLXP9v$KlyYeI/lUg1ogsGLr4/1kjTHEvm4hw0r06PcvI8UeK2

# Create user account
user --groups=wheel,docker --name=jakub --password=$y$j9T$V6eFSDElTVYzcJjXAmRhRTMT$VS86h3X2ATJl5.1hkEf1QLYcfjsj6kEf36sUcnD3aY7 --iscrypted --gecos="jakub"

# System timezone
timezone Europe/Warsaw --utc

# Disk partitioning - clear all partitions and use automatic partitioning
ignoredisk --only-use=sda
clearpart --all --initlabel
autopart

# System bootloader configuration
bootloader --append="rhgb quiet" --location=mbr --boot-drive=sda

# Firewall configuration
firewall --enabled --service=ssh

# SELinux configuration
selinux --enforcing

# System services
services --enabled=NetworkManager,sshd

# Skip X Window System configuration
skipx

# Do not configure the first boot assistant
firstboot --disable

# Reboot after installation
reboot

%packages
@^server-product-environment
wget
curl
git
tar
gzip
gcc
make
cmake
# VirtualBox Guest Additions dependencies
kernel-devel
kernel-headers
dkms
%end

%post --log=/var/log/anaconda-post.log

# Enable and start essential services
systemctl enable NetworkManager
systemctl enable sshd

# Create directories for cJSON application
mkdir -p /opt/cjson
mkdir -p /var/log/cjson
mkdir -p /etc/systemd/system

# Download Docker GPG key and set up repository (backup method if repo didn't work)
# curl -fsSL https://download.docker.com/linux/fedora/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# Create cJSON library installer and application launcher script
cat > /opt/cjson/install-cjson.sh << 'EOF'
#!/bin/bash

# cJSON Library Installer and Application Runner
# This script downloads the cJSON library package from Jenkins and installs it

LOG_FILE="/var/log/cjson/cjson-app.log"
JENKINS_URL="http://your-jenkins-server:8080"
JENKINS_JOB="cjson-pipeline"
PACKAGE_PREFIX="cjson-package"

# Function to log messages
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log_message "Starting cJSON library installation and deployment..."

# Create temporary directory
mkdir -p /tmp/cjson-install
cd /tmp/cjson-install

# Try to download the latest cJSON package from Jenkins
log_message "Attempting to download cJSON package from Jenkins..."

# Get the latest successful build number
BUILD_NUM=$(curl -s "$JENKINS_URL/job/$JENKINS_JOB/lastSuccessfulBuild/buildNumber" 2>/dev/null || echo "latest")
PACKAGE_NAME="${PACKAGE_PREFIX}-v${BUILD_NUM}.tar.gz"

# Try different package name patterns
for pkg_pattern in "${PACKAGE_PREFIX}-v${BUILD_NUM}.tar.gz" "${PACKAGE_PREFIX}-latest.tar.gz" "cjson-package*.tar.gz"; do
    log_message "Trying to download: $pkg_pattern"
    if wget -q "$JENKINS_URL/job/$JENKINS_JOB/lastSuccessfulBuild/artifact/$pkg_pattern" -O cjson-package.tar.gz 2>/dev/null; then
        log_message "Successfully downloaded cJSON package: $pkg_pattern"
        break
    fi
done

if [ -f "cjson-package.tar.gz" ]; then
    log_message "Extracting cJSON package..."
    tar -xzf cjson-package.tar.gz
    
    # Find the extracted directory
    PACKAGE_DIR=$(find . -maxdepth 1 -type d -name "${PACKAGE_PREFIX}*" | head -1)
    
    if [ -n "$PACKAGE_DIR" ]; then
        log_message "Installing cJSON library from $PACKAGE_DIR..."
        
        # Install library files
        if [ -f "$PACKAGE_DIR/lib/libcjson.so.1.7.18" ]; then
            cp "$PACKAGE_DIR"/lib/libcjson.so* /usr/lib64/ 2>/dev/null || cp "$PACKAGE_DIR"/lib/libcjson.so* /usr/lib/
            log_message "Installed shared library"
        fi
        
        if [ -f "$PACKAGE_DIR/lib/libcjson.a" ]; then
            cp "$PACKAGE_DIR/lib/libcjson.a" /usr/lib64/ 2>/dev/null || cp "$PACKAGE_DIR/lib/libcjson.a" /usr/lib/
            log_message "Installed static library"
        fi
        
        if [ -f "$PACKAGE_DIR/include/cJSON.h" ]; then
            cp "$PACKAGE_DIR/include/cJSON.h" /usr/include/
            log_message "Installed header file"
        fi
        
        # Update library cache
        ldconfig
        log_message "Updated library cache"
        
        # Copy documentation
        if [ -d "$PACKAGE_DIR/docs" ]; then
            mkdir -p /usr/share/doc/cjson
            cp "$PACKAGE_DIR"/docs/* /usr/share/doc/cjson/ 2>/dev/null || true
            log_message "Installed documentation"
        fi
        
    else
        log_message "Could not find extracted package directory"
        exit 1
    fi
    
else
    log_message "Could not download cJSON package from Jenkins, building from source..."
    
    # Fallback: build from source
    dnf install -y gcc cmake make
    git clone https://github.com/DaveGamble/cJSON.git
    cd cJSON
    mkdir build && cd build
    cmake .. -DENABLE_CJSON_TEST=On -DBUILD_SHARED_LIBS=On
    make
    
    # Install the library
    cp libcjson.so* /usr/lib64/ 2>/dev/null || cp libcjson.so* /usr/lib/
    cp ../cJSON.h /usr/include/
    ldconfig
    
    cd /tmp/cjson-install
    log_message "Built and installed cJSON from source"
fi

# Create example application
log_message "Creating cJSON example application..."

cat > /opt/cjson/cjson-example.c << 'C_EOF'
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include "cJSON.h"

int main() {
    printf("=== cJSON Application Starting ===\n");
    
    while (1) {
        // Get current time
        time_t now = time(NULL);
        char *time_str = ctime(&now);
        // Remove newline from time string
        if (time_str && time_str[strlen(time_str)-1] == '\n') {
            time_str[strlen(time_str)-1] = '\0';
        }
        
        // Create JSON object
        cJSON *json = cJSON_CreateObject();
        cJSON *name = cJSON_CreateString("cJSON");
        cJSON *version = cJSON_CreateString("deployed");
        cJSON *status = cJSON_CreateString("running");
        cJSON *timestamp = cJSON_CreateString(time_str ? time_str : "unknown");
        cJSON *pid = cJSON_CreateNumber(getpid());
        
        cJSON_AddItemToObject(json, "name", name);
        cJSON_AddItemToObject(json, "version", version);
        cJSON_AddItemToObject(json, "status", status);
        cJSON_AddItemToObject(json, "timestamp", timestamp);
        cJSON_AddItemToObject(json, "pid", pid);
        
        // Convert to string and print
        char *json_string = cJSON_Print(json);
        printf("%s\n", json_string);
        
        // Cleanup
        free(json_string);
        cJSON_Delete(json);
        
        // Wait 30 seconds before next output
        sleep(30);
    }
    
    return 0;
}
C_EOF

# Compile the example application
log_message "Compiling cJSON example application..."
cd /opt/cjson
gcc -o cjson-example cjson-example.c -lcjson

if [ $? -eq 0 ]; then
    log_message "Successfully compiled cJSON example application"
    chmod +x cjson-example
else
    log_message "Failed to compile cJSON example application"
    exit 1
fi

# Test the library installation
log_message "Testing cJSON library installation..."
timeout 5 ./cjson-example > /dev/null 2>&1
if [ $? -eq 124 ]; then  # timeout exit code
    log_message "cJSON library test successful (timeout as expected)"
else
    log_message "cJSON library test completed"
fi

# Cleanup
cd /
rm -rf /tmp/cjson-install

log_message "cJSON library installation and application setup completed"
EOF

# Make the script executable
chmod +x /opt/cjson/install-cjson.sh

# Create application runner script
cat > /opt/cjson/run-cjson.sh << 'EOF'
#!/bin/bash
LOG_FILE="/var/log/cjson/cjson-app.log"

log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log_message "Starting cJSON native application..."

# Check if library is installed
if ! ldconfig -p | grep -q libcjson; then
    log_message "cJSON library not found, running installation..."
    /opt/cjson/install-cjson.sh
    if [ $? -ne 0 ]; then
        log_message "Failed to install cJSON library"
        exit 1
    fi
fi

# Run the application
if [ -f "/opt/cjson/cjson-example" ]; then
    log_message "Running cJSON example application..."
    exec /opt/cjson/cjson-example
else
    log_message "cJSON example application not found"
    exit 1
fi
EOF

chmod +x /opt/cjson/run-cjson.sh

# Create systemd service for cJSON application
cat > /etc/systemd/system/cjson-app.service << 'EOF'
[Unit]
Description=cJSON Native Application Service
After=multi-user.target
After=network.target

[Service]
Type=simple
ExecStartPre=/opt/cjson/install-cjson.sh
ExecStart=/opt/cjson/cjson-example
Restart=always
RestartSec=10
User=root
StandardOutput=journal
StandardError=journal
WorkingDirectory=/opt/cjson

[Install]
WantedBy=multi-user.target
EOF

# Enable the cJSON service
systemctl enable cjson-app.service

# Create a script to check application status
cat > /opt/cjson/check-status.sh << 'EOF'
#!/bin/bash
echo "=== cJSON Application Status ==="
echo "cJSON service status:"
systemctl status cjson-app.service --no-pager -l

echo -e "\nLibrary installation check:"
ldconfig -p | grep cjson || echo "cJSON library not found in ldconfig cache"

echo -e "\nLibrary files:"
ls -la /usr/lib*/libcjson* 2>/dev/null || echo "No library files found"
echo "Header file:"
ls -la /usr/include/cJSON.h 2>/dev/null || echo "Header file not found"

echo -e "\nRecent application logs:"
tail -20 /var/log/cjson/cjson-app.log 2>/dev/null || echo "No logs found yet"

echo -e "\nSystemd journal logs:"
journalctl -u cjson-app.service --no-pager -l -n 10 2>/dev/null || echo "No systemd logs found"

echo -e "\nApplication process:"
pgrep -f cjson-example && ps aux | grep cjson-example | grep -v grep || echo "Application not running"
EOF

chmod +x /opt/cjson/check-status.sh

# Create helpful aliases
cat >> /home/jakub/.bashrc << 'EOF'

# cJSON Application aliases
alias cjson-status='/opt/cjson/check-status.sh'
alias cjson-logs='journalctl -u cjson-app.service -f'
alias cjson-restart='sudo systemctl restart cjson-app.service'
alias cjson-install='sudo /opt/cjson/install-cjson.sh'
EOF

# Set up log rotation for cJSON logs
cat > /etc/logrotate.d/cjson << 'EOF'
/var/log/cjson/*.log {
    daily
    rotate 7
    compress
    missingok
    notifempty
    create 0644 root root
}
EOF

# Create welcome message
cat > /etc/motd << 'EOF'
========================================
  Fedora Server with cJSON Library
========================================

This system has been automatically configured with:
- cJSON library from Jenkins pipeline
- Native cJSON application service
- Automatic library management

Useful commands:
- cjson-status  : Check application status
- cjson-logs    : View application logs (live)
- cjson-restart : Restart the application
- cjson-install : Reinstall cJSON library

Application logs: /var/log/cjson/cjson-app.log
Configuration: /opt/cjson/
Service: systemctl status cjson-app.service

========================================
EOF

# Final setup
chown -R jakub:jakub /home/jakub
chmod 755 /opt/cjson

# Log completion
echo "[$(date)] Post-installation script completed successfully" >> /var/log/anaconda-post.log

%end