pipeline {
    agent any
    
    stages {
        stage('Checkout') {
            steps {
                // Pobranie kodu źródłowego z głównego repozytorium
                git url: 'https://github.com/DaveGamble/cJSON.git', branch: 'master'
                
                // Pobranie plików Dockerfile z repozytorium projektu
                dir('project_files') {
                    git url: 'https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO.git', branch: 'main'
                    sh 'git checkout JS415003 || echo "Branch not found, continuing with main"'
                }
                
                // Kopiowanie plików Dockerfile z odpowiedniej struktury katalogów
                sh '''
                mkdir -p dockerfiles
                cp project_files/ITE/GCL07/JS415003/Sprawozdanie2/Dockerfile.cjsonbuild dockerfiles/
                cp project_files/ITE/GCL07/JS415003/Sprawozdanie2/Dockerfile.cjsontest dockerfiles/
                cp project_files/ITE/GCL07/JS415003/Sprawozdanie2/Dockerfile.cjsondeploy dockerfiles/
                
                # Kopiowanie Dockerfile'i do katalogu głównego projektu
                cp dockerfiles/Dockerfile.cjsonbuild ${WORKSPACE}/
                cp dockerfiles/Dockerfile.cjsontest ${WORKSPACE}/
                cp dockerfiles/Dockerfile.cjsondeploy ${WORKSPACE}/
                '''
                
                // Tworzenie przykładowego pliku C do demonstracji działania biblioteki
                sh '''
                cat > example.c << 'ENDOFFILE'
#include <stdio.h>
#include <stdlib.h>
#include "cJSON.h"

int main() {
    const char *json_string = "{\\\"name\\\":\\\"cJSON\\\", \\\"version\\\":\\\"1.0\\\", \\\"status\\\":\\\"deployed\\\"}";
    cJSON *json = cJSON_Parse(json_string);
    
    if (json == NULL) {
        printf("Error parsing JSON\\n");
        return 1;
    }
    
    cJSON *name = cJSON_GetObjectItemCaseSensitive(json, "name");
    cJSON *version = cJSON_GetObjectItemCaseSensitive(json, "version");
    cJSON *status = cJSON_GetObjectItemCaseSensitive(json, "status");
    
    printf("Library: %s\\nVersion: %s\\nStatus: %s\\n",
        name->valuestring, version->valuestring, status->valuestring);
    
    cJSON_Delete(json);
    return 0;
}
ENDOFFILE
                '''
            }
        }
        
        stage('Build') {
            steps {
                sh 'docker rmi -f cjson-build || true'
                sh 'docker rmi -f cjson-test || true'
                sh 'docker rmi -f cjson-deploy || true'

                // Budowanie obrazu Builder
                sh 'docker build -t cjson-build -f Dockerfile.cjsonbuild .'
            }
        }
        
        stage('Test') {
            steps {
                // Uruchomienie testów
                sh 'docker build -t cjson-test -f Dockerfile.cjsontest .'
                sh 'docker run --name cjson-test-container cjson-test || true'
                
                // Zapisanie wyników testów
                sh 'docker cp cjson-test-container:/cjson-build/build/Testing . || echo "Nie znaleziono katalogu Testing"'
                sh 'docker rm cjson-test-container || true'
                
                // Archiwizacja wyników testów
                archiveArtifacts artifacts: 'Testing/**/*', fingerprint: true, allowEmptyArchive: true
            }
        }
        
        stage('Deploy') {
            steps {
                // Budowanie i uruchamianie kontenera deploy
                sh 'docker build --no-cache -t cjson-deploy -f Dockerfile.cjsondeploy .'
                sh 'docker run --rm cjson-deploy > deploy_results.txt || echo "Deploy container failed" > deploy_results.txt'
                
                // Archiwizacja wyników wdrożenia
                archiveArtifacts artifacts: 'deploy_results.txt', fingerprint: true
            }
        }
        
        stage('Publish') {
            steps {
                // Publikacja pakietu przy użyciu CMake zgodnie z README projektu
                sh '''
                # Usunięcie istniejącego kontenera, jeśli taki istnieje
                docker rm -f cjson-build-container || true
                
                # Tworzenie i uruchamianie kontenera z obrazu cjson-build
                docker run --name cjson-build-container -d cjson-build tail -f /dev/null
                
                # Wypiszmy listę plików w kontenerze w katalogu build, aby zobaczyć co zostało wygenerowane
                echo "Pliki w katalogu build:"
                docker exec cjson-build-container ls -la /cjson-build/build/
                
                # Sprawdzenie zawartości kontenera, aby znaleźć pliki
                echo "Szukanie libcjson.a:"
                docker exec cjson-build-container find / -name "libcjson.a" || echo "libcjson.a not found"
                echo "Szukanie libcjson.so:"
                docker exec cjson-build-container find / -name "libcjson.so*" || echo "libcjson.so not found"
                echo "Szukanie cJSON.h:"
                docker exec cjson-build-container find / -name "cJSON.h" || echo "cJSON.h not found"
                
                # Kopiowanie plików z kontenera build
                echo "Kopiowanie plików z kontenera..."
                
                # Kopiowanie shared library - używamy konkretnego pliku libcjson.so.1.7.18
                docker cp cjson-build-container:/cjson-build/build/libcjson.so.1.7.18 .
                
                # Sprawdzenie czy kopiowanie się powiodło i wykonanie symlinków lokalnie
                if [ -f libcjson.so.1.7.18 ]; then
                  ln -sf libcjson.so.1.7.18 libcjson.so.1
                  ln -sf libcjson.so.1 libcjson.so
                  echo "Successfully copied and linked libcjson.so"
                else
                  echo "Failed to copy libcjson.so.1.7.18"
                fi
                
                # Kopiowanie pliku nagłówkowego
                docker cp cjson-build-container:/cjson-build/cJSON.h .
                
                # Zatrzymanie i usunięcie kontenera
                docker stop cjson-build-container
                docker rm cjson-build-container
                
                # Tworzenie katalogu pakietu
                mkdir -p cjson-package/lib
                mkdir -p cjson-package/include
                
                # Kopiowanie plików do pakietu
                if [ -f libcjson.so.1.7.18 ]; then 
                  cp libcjson.so.1.7.18 cjson-package/lib/
                  cp libcjson.so.1 cjson-package/lib/
                  cp libcjson.so cjson-package/lib/
                  echo "Added libcjson.so files to package"
                else
                  echo "libcjson.so files not found"
                fi
                
                if [ -f cJSON.h ]; then 
                  cp cJSON.h cjson-package/include/
                  echo "Added cJSON.h to package"
                else
                  echo "cJSON.h not found"
                fi
                
                # Kopiowanie dokumentacji
                if [ -f LICENSE ]; then 
                  cp LICENSE cjson-package/
                  echo "Added LICENSE to package"
                fi
                
                if [ -f README.md ]; then 
                  cp README.md cjson-package/
                  echo "Added README.md to package"
                fi
                
                # Tworzenie podstawowego archiwum
                tar -czvf cjson-package.tar.gz cjson-package/
                echo "Created cjson-package.tar.gz"
                '''
                
                // Archiwizacja pakietu
                archiveArtifacts artifacts: 'cjson-package.tar.gz', fingerprint: true
            }
        }
    }
    
    post {
        success {
            echo 'Pipeline zakończony sukcesem!'
        }
        failure {
            echo 'Pipeline zakończony niepowodzeniem!'
        }
    }
}