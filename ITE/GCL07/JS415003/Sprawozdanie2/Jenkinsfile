pipeline {
    agent any
    
    environment {
        VERSION = "v${BUILD_NUMBER}"
        CJSON_BUILD = "cjson-build:${VERSION}"
        CJSON_TEST = "cjson-test:${VERSION}"
        CJSON_DEPLOY = "cjson-deploy:${VERSION}"
        DOCKERHUB_REPO = "sadlowskijj/cjson-deploy"
        IMAGE_TAG = "${DOCKERHUB_REPO}:${VERSION}"
        PACKAGE_NAME = "cjson-package-${VERSION}"
    }
    
    stages {
        stage('Cleanup') {
            steps {
                sh '''
                    docker container ls -a -q | xargs -r docker rm -f
                    docker volume ls -q | xargs -r docker volume rm -f
                    docker network ls -q --filter type=custom | xargs -r docker network rm -f
                    docker builder prune --all --force
                    docker images -q | grep -E 'cjson-(build|test|deploy)' | xargs -r docker rmi -f
                '''
            }
        }
        
        stage('Checkout') {
            steps {
                git url: 'https://github.com/DaveGamble/cJSON.git', branch: 'master'
                
                dir('project_files') {
                    git url: 'https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO.git', branch: 'main'
                    sh 'git checkout JS415003 || echo "Branch not found, continuing with main"'
                }
                
                sh '''
                    mkdir -p dockerfiles
                    cp project_files/ITE/GCL07/JS415003/Sprawozdanie2/Dockerfile.cjsonbuild dockerfiles/
                    cp project_files/ITE/GCL07/JS415003/Sprawozdanie2/Dockerfile.cjsontest dockerfiles/
                    cp project_files/ITE/GCL07/JS415003/Sprawozdanie2/Dockerfile.cjsondeploy dockerfiles/
                    
                    # Kopiowanie Dockerfile'i do katalogu głównego projektu
                    cp dockerfiles/Dockerfile.cjsonbuild ${WORKSPACE}/
                    cp dockerfiles/Dockerfile.cjsontest ${WORKSPACE}/
                    cp dockerfiles/Dockerfile.cjsondeploy ${WORKSPACE}/
                '''
                
                sh '''
                    cat > example.c << 'EOT'
#include <stdio.h>
#include <stdlib.h>
#include "cJSON.h"

int main() {
    const char *json_string = "{\\"name\\":\\"cJSON\\", \\"version\\":\\"${VERSION}\\", \\"status\\":\\"deployed\\"}";
    cJSON *json = cJSON_Parse(json_string);

    if (json == NULL) {
        printf("Error parsing JSON\\n");
        return 1;
    }

    cJSON *name = cJSON_GetObjectItemCaseSensitive(json, "name");
    cJSON *version = cJSON_GetObjectItemCaseSensitive(json, "version");
    cJSON *status = cJSON_GetObjectItemCaseSensitive(json, "status");

    printf("Library: %s\\nVersion: %s\\nStatus: %s\\n",
        name->valuestring, version->valuestring, status->valuestring);

    cJSON_Delete(json);
    return 0;
}
EOT

                    sed -i "s/\\\${VERSION}/${VERSION}/g" example.c
                '''
            }
        }
        
        stage('Build') {
            steps {
                sh 'docker build -t ${CJSON_BUILD} -f Dockerfile.cjsonbuild .'
                
                // Also tag the build image as 'latest' for Dockerfile references
                sh 'docker tag ${CJSON_BUILD} cjson-build:latest'
                
                // Pobieranie czasu budowania dla raportowania
                sh 'echo "Build completed at $(date)" > build_time.log'
                archiveArtifacts artifacts: 'build_time.log', fingerprint: true
            }
        }
        
        stage('Test') {
            steps {
                // Uruchomienie testów z logowaniem wyniku
                sh 'docker build -t ${CJSON_TEST} -f Dockerfile.cjsontest .'
                
                // Also tag the test image as 'latest' for potential use in deploy
                sh 'docker tag ${CJSON_TEST} cjson-test:latest'
                
                sh '''
                    docker run --name cjson-test-container ${CJSON_TEST} > test_results_${VERSION}.log 2>&1 || \
                    echo "Tests failed with exit code $?" >> test_results_${VERSION}.log
                '''
                
                // Zapisanie wyników testów
                sh 'docker cp cjson-test-container:/cjson-build/build/Testing . || echo "Testing directory not found"'
                sh 'docker rm cjson-test-container || true'
                
                // Archiwizacja wyników testów
                archiveArtifacts artifacts: "test_results_${VERSION}.log", fingerprint: true
                archiveArtifacts artifacts: 'Testing/**/*', fingerprint: true, allowEmptyArchive: true
            }
        }
        
        stage('SmokeTest') {
            steps {
                // Budowanie obrazu deploy
                sh 'docker build --no-cache -t ${CJSON_DEPLOY} -f Dockerfile.cjsondeploy .'
                
                // Wykonanie smoke testu w izolowanej sieci
                sh '''
                    docker network create smoke-test-net || true
                    docker run --rm --network smoke-test-net --name cjson-smoke-test ${CJSON_DEPLOY} > smoke_test_${VERSION}.log
                    docker network rm smoke-test-net || true
                '''
                
                // Archiwizacja wyników smoke testu
                archiveArtifacts artifacts: "smoke_test_${VERSION}.log", fingerprint: true
            }
        }
        
        stage('Package') {
    steps {
        sh '''
            docker rm -f cjson-build-container || true
            docker run --name cjson-build-container -d ${CJSON_BUILD} tail -f /dev/null

            mkdir -p ${PACKAGE_NAME}/lib
            mkdir -p ${PACKAGE_NAME}/include
            mkdir -p ${PACKAGE_NAME}/docs

            docker cp cjson-build-container:/cjson-build/build/libcjson.so.1.7.18 ${PACKAGE_NAME}/lib/ || echo "libcjson.so.1.7.18 not found"
            if [ -f ${PACKAGE_NAME}/lib/libcjson.so.1.7.18 ]; then
                (cd ${PACKAGE_NAME}/lib/ && ln -sf libcjson.so.1.7.18 libcjson.so.1 && ln -sf libcjson.so.1 libcjson.so)
            fi

            docker cp cjson-build-container:/cjson-build/build/libcjson.a ${PACKAGE_NAME}/lib/ || echo "libcjson.a not found"
            docker cp cjson-build-container:/cjson-build/cJSON.h ${PACKAGE_NAME}/include/
            docker cp cjson-build-container:/cjson-build/README.md ${PACKAGE_NAME}/docs/
            docker cp cjson-build-container:/cjson-build/LICENSE ${PACKAGE_NAME}/docs/
            docker cp cjson-build-container:/cjson-build/CHANGELOG.md ${PACKAGE_NAME}/docs/ || echo "CHANGELOG.md not found"

            cat > ${PACKAGE_NAME}/README.txt << 'EOT'
cJSON Library Package ${VERSION}
===========================

This package contains:
- Dynamic library in lib/
- Static library in lib/
- Header files in include/
- Documentation in docs/

To use:
1. Copy libcjson.so* to your system library path or application directory
2. Copy cJSON.h to your include path
3. Compile with -lcjson flag

Example: gcc -o myapp myapp.c -I./include -L./lib -lcjson
EOT
            sed -i "s/\\\${VERSION}/${VERSION}/g" ${PACKAGE_NAME}/README.txt

            docker stop cjson-build-container
            docker rm cjson-build-container

            tar -czvf ${PACKAGE_NAME}.tar.gz ${PACKAGE_NAME}/
        '''
        archiveArtifacts artifacts: "${PACKAGE_NAME}.tar.gz", fingerprint: true
    }
}

        
    //     stage('Publish') {
    //         steps {
                
    //             }
    //         }
    // }
    
    post {
        success {
            echo "Pipeline completed successfully! The cJSON library has been built, tested, packaged and published as version ${VERSION}"
        }
        failure {
            echo "Pipeline failed! Check the logs for details."
        }
        always {
            sh '''
                echo "=== Cleaning up containers and temporary files ==="
                docker rm -f cjson-build-container || true
                docker rm -f cjson-test-container || true
                rm -rf ${PACKAGE_NAME} || true
                echo "=== Cleanup done ==="
            '''
        }
    }
}
}