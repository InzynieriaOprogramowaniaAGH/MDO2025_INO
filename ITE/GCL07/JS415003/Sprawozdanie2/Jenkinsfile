pipeline {
    agent any
    
    stages {
        stage('Checkout') {
            steps {
                // Pobranie kodu źródłowego z głównego repozytorium
                git url: 'https://github.com/DaveGamble/cJSON.git', branch: 'master'
                
                // Pobranie plików Dockerfile z repozytorium projektu
                dir('project_files') {
                    git url: 'https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO.git', branch: 'main'
                    sh 'git checkout JS415003 || echo "Branch not found, continuing with main"'
                }
                
                // Kopiowanie plików Dockerfile z odpowiedniej struktury katalogów
                sh '''
                mkdir -p dockerfiles
                cp project_files/ITE/GCL07/JS415003/Sprawozdanie2/Dockerfile.cjsonbuild dockerfiles/
                cp project_files/ITE/GCL07/JS415003/Sprawozdanie2/Dockerfile.cjsontest dockerfiles/
                cp project_files/ITE/GCL07/JS415003/Sprawozdanie2/Dockerfile.cjsondeploy dockerfiles/
                
                # Kopiowanie Dockerfile'i do katalogu głównego projektu
                cp dockerfiles/Dockerfile.cjsonbuild ${WORKSPACE}/
                cp dockerfiles/Dockerfile.cjsontest ${WORKSPACE}/
                cp dockerfiles/Dockerfile.cjsondeploy ${WORKSPACE}/
                '''
                
                // Tworzenie przykładowego pliku C do demonstracji działania biblioteki
                sh '''
                cat > example.c << 'ENDOFFILE'
#include <stdio.h>
#include <stdlib.h>
#include "cJSON.h"

int main() {
    const char *json_string = "{\\\"name\\\":\\\"cJSON\\\", \\\"version\\\":\\\"1.0\\\", \\\"status\\\":\\\"deployed\\\"}";
    cJSON *json = cJSON_Parse(json_string);
    
    if (json == NULL) {
        printf("Error parsing JSON\\n");
        return 1;
    }
    
    cJSON *name = cJSON_GetObjectItemCaseSensitive(json, "name");
    cJSON *version = cJSON_GetObjectItemCaseSensitive(json, "version");
    cJSON *status = cJSON_GetObjectItemCaseSensitive(json, "status");
    
    printf("Library: %s\\nVersion: %s\\nStatus: %s\\n",
        name->valuestring, version->valuestring, status->valuestring);
    
    cJSON_Delete(json);
    return 0;
}
ENDOFFILE
                '''
            }
        }
        
        stage('Build') {
            steps {
                sh 'docker rmi -f cjson-build || true'
                sh 'docker rmi -f cjson-test || true'
                sh 'docker rmi -f cjson-deploy || true'

                // Budowanie obrazu Builder
                sh 'docker build -t cjson-build -f Dockerfile.cjsonbuild .'
            }
        }
        
        stage('Test') {
            steps {
                // Uruchomienie testów
                sh 'docker build -t cjson-test -f Dockerfile.cjsontest .'
                sh 'docker run --name cjson-test-container cjson-test || true'
                
                // Zapisanie wyników testów
                sh 'docker cp cjson-test-container:/cjson-build/build/Testing .'
                sh 'docker rm cjson-test-container'
                
                // Archiwizacja wyników testów
                archiveArtifacts artifacts: 'Testing/**/*', fingerprint: true
            }
        }
        
        stage('Deploy') {
            steps {
                // Budowanie i uruchamianie kontenera deploy
                sh 'docker build --no-cache -t cjson-deploy -f Dockerfile.cjsondeploy .'
                sh 'docker run --rm cjson-deploy > deploy_results.txt'
                
                // Archiwizacja wyników wdrożenia
                archiveArtifacts artifacts: 'deploy_results.txt', fingerprint: true
            }
        }
        
        stage('Publish') {
            steps {
                // Publikacja pakietu przy użyciu CMake zgodnie z README projektu
                sh '''
                # Tworzenie i uruchamianie kontenera z obrazu cjson-build
                docker run --name cjson-build-container -d cjson-build tail -f /dev/null
                
                # Sprawdzenie zawartości kontenera, aby znaleźć pliki
                docker exec cjson-build-container find / -name "libcjson.a" || echo "libcjson.a not found"
                docker exec cjson-build-container find / -name "libcjson.so" || echo "libcjson.so not found"
                docker exec cjson-build-container find / -name "cJSON.h" || echo "cJSON.h not found"
                
                # Kopiowanie plików z kontenera build (używając bezpiecznego podejścia)
                # Najpierw próbujemy standardowe ścieżki
                docker cp cjson-build-container:/cjson-build/build/libcjson.so . || echo "Could not copy libcjson.so from expected path"
                
                # Próbujemy alternatywne ścieżki dla libcjson.a jeśli standardowa zawodzi
                docker cp cjson-build-container:/cjson-build/build/libcjson.a . || \
                docker cp cjson-build-container:/usr/local/lib/libcjson.a . || \
                docker cp cjson-build-container:/usr/lib/libcjson.a . || \
                echo "Could not find libcjson.a in any standard location"
                
                # Próbujemy znaleźć cJSON.h
                docker cp cjson-build-container:/cjson-build/cJSON.h . || \
                docker cp cjson-build-container:/usr/local/include/cJSON.h . || \
                docker cp cjson-build-container:/usr/include/cJSON.h . || \
                echo "Could not find cJSON.h in any standard location"
                
                # Zatrzymanie i usunięcie kontenera
                docker stop cjson-build-container
                docker rm cjson-build-container
                
                # Tworzenie katalogu pakietu
                mkdir -p cjson-package/lib
                mkdir -p cjson-package/include
                
                # Kopiowanie plików do pakietu tylko jeśli istnieją
                if [ -f libcjson.so ]; then cp libcjson.so cjson-package/lib/; fi
                if [ -f libcjson.a ]; then cp libcjson.a cjson-package/lib/; fi
                if [ -f cJSON.h ]; then cp cJSON.h cjson-package/include/; fi
                
                # Kopiowanie dokumentacji jeśli pliki istnieją
                if [ -f LICENSE ]; then cp LICENSE cjson-package/; fi
                if [ -f README.md ]; then cp README.md cjson-package/; fi
                
                # Tworzenie podstawowego archiwum
                tar -czvf cjson-package.tar.gz cjson-package/
                '''
                
                // Archiwizacja pakietu
                archiveArtifacts artifacts: 'cjson-package.tar.gz', fingerprint: true
            }
        }
    }
    
    post {
        success {
            echo 'Pipeline zakończony sukcesem!'
        }
        failure {
            echo 'Pipeline zakończony niepowodzeniem!'
        }
    }
}