## Sprawozdanie 8-11
### Patrycja Wojdyło

## Instalacja Fedory

Celem ćwiczenia było przygotowanie środowiska do pracy z Ansible, obejmujące utworzenie maszyny docelowej, konfigurację komunikacji SSH, instalację Ansible na maszynie głównej, wykonywanie zdalnych zadań za pomocą playbooków oraz zarządzanie artefaktami z poprzednich etapów CI/CD.


Utworzyłam drugą maszyne wirtualna z systemem Fedora, takim samym jak na maszynie głównej. Na nowej maszynie zainstalowałam program `tar` oraz `OpenSSH`, ustawiłam hostname `ansible-target` i utworzyłam użytkownika `ansible` używając komend `sudo dnf install tar sshd`, `sudo hostnamectl set-hostname ansible-target`.

![alt text](<part1/Zrzut ekranu 2025-06-09 192027.png>)

![alt text](<part1/Zrzut ekranu 2025-06-09 192346.png>)

Na głównej maszynie zainstalowałam ansible poleceniem `sudo dnf install -y ansible`.
![alt text](<part1/Zrzut ekranu 2025-06-09 192758.png>)

Wygenerowałam klucz SSH dla użytkownika na maszynie głównej i przesłałam go na maszynę docelową.

![alt text](<part1/Zrzut ekranu 2025-06-09 202219.png>)

I sprawdziłam czy logowanie działa poprawnie bez hasła

![alt text](<part1/Zrzut ekranu 2025-06-09 202249.png>)


Dodałam wpisy DNS do `/etc/hosts`
![alt text](<part1/Zrzut ekranu 2025-06-09 203515.png>)

Sprawdziłam łączność z maszyną docelową, wykonując polecenia `ping` oraz `ssh` z maszyny głównej.

![alt text](<part1/Zrzut ekranu 2025-06-09 203804.png>)
![alt text](<part1/Zrzut ekranu 2025-06-09 204006.png>)

Stworzyłam plik Ansible inventory.ini:
![alt text](<part1/Zrzut ekranu 2025-06-09 204200.png>)


Sprawdziłam dostępność maszyny docelowej za pomocą polecenia `ping` w `Ansible`. Wszystko wykonało się prawidłowo.

![alt text](<part1/Zrzut ekranu 2025-06-09 204720.png>)

Playbook


Utworzyłam playbooka Ansible, za pomocą którego wysłałam żądanie ping:
![alt text](<part2/Zrzut ekranu 2025-06-12 160452.png>)
Aby uniknąć podawania hasła, skonfigurowałam użytkownika ansible do wykonywania poleceń sudo bez hasła, edytujać plik dodając do niego:

`ansible ALL=(ALL) NOPASSWD: ALL`

Wynik:
![alt text](<part2/Zrzut ekranu 2025-06-12 160501.png>)

Edytowałam `playbook`, aby kopiował plik `inventory.ini` aktualizował pakiety i restartował usługi `sshd` oraz `rngd`.

![alt text](<part2/Zrzut ekranu 2025-06-12 161735.png>)

Przeprowadziłam test, zatrzymując usługę `SSH` na maszynie poleceniem `sudo systemctl stop sshd`. Po ponownym uruchomieniu playbooka na maszynie głównej, operacja nie powiodła się, a maszyna została oznaczona jako UNREACHABLE.
![alt text](<part2/Zrzut ekranu 2025-06-12 161934.png>)

Zarządzenie atefaktami za pomocą Ansible

Stworzyłam rolę Ansible za pomocą komendy - `ansible-galaxy init html_report`.

Umieściłam w pliku `html_report/tasks/main.yml` playbook, który instaluje Dockera i curl, uruchamia i konfiguruje Dockera, kopiuje raport, uruchamia kontener nginx z odpowiednim mapowaniem, sprawdza dostępność strony raportu oraz na końcu zatrzymuje i usuwa kontener.

Plik main.yml:
```
---
- name: Zainstaluj Docker i curl (tylko na Fedorze)
  dnf:
    name:
      - docker
      - curl
    state: present
    update_cache: yes

- name: Włącz i uruchom usługę Docker
  service:
    name: docker
    state: started
    enabled: yes

- name: Skopiuj cały raport HTML (lcov-report) na maszynę zdalną
  copy:
    src: lcov-report/
    dest: /srv/report/
    mode: '0755'


- name: Uruchom kontener NGINX serwujący raport
  docker_container:
    name: html-server
    image: nginx:alpine
    state: started
    ports:
      - "8888:80"
    volumes:
      - /srv/report:/usr/share/nginx/html
    restart_policy: unless-stopped

- name: Sprawdź, czy raport działa (HTTP 200)
  uri:
    url: http://localhost:8888/index.html
    status_code: 200
    return_content: yes
  register: html_response

- name: Wyświetl fragment zawartości raportu
  debug:
    msg: "{{ html_response.content[:500] }}"

- name: Usuń kontener po sprawdzeniu
  docker_container:
    name: html-server
    state: absent
    force_kill: true
```

![alt text](<part2/Zrzut ekranu 2025-06-12 233213.png>)

Po uruchomieniu kontenera za pomocą Ansible, logi wskazywały, że skrypt został wykonany poprawnie.

![alt text](<part2/Zrzut ekranu 2025-06-12 232754.png>)


## Pliki odpowiedzi dla wdrożeń nienadzorowanych


Żeby pobrać plik konfiguracyjny z systemu użyłam polecenia `sudo cat /root/anaconda-ks.cfg`.


![alt text](<part3/Zrzut ekranu 2025-06-12 204500.png>)

plik anaconda-ks.cfg
```
# Generated by Anaconda 41.35
# Generated by pykickstart v3.58
#version=DEVEL

# Keyboard layouts
keyboard --vckeymap=pl --xlayouts='pl'
# System language
lang pl_PL.UTF-8

# Network information
network  --bootproto=dhcp --device=enp0s3 --ipv6=auto --activate
network  --hostname=patrycja

%packages
@^server-product-environment

%end

# Run the Setup Agent on first boot
firstboot --enable

# Generated using Blivet version 3.11.0
ignoredisk --only-use=sda
# Partition clearing information
clearpart --all --initlabel
# Disk partitioning information
part /boot --fstype="ext4" --ondisk=sda --size=1024
part /boot/efi --fstype="efi" --ondisk=sda --size=600 --fsoptions="umask=0077,shortname=winnt"
part pv.48 --fstype="lvmpv" --ondisk=sda --size=13734
volgroup fedora_patrycja --pesize=4096 pv.48
logvol / --fstype="ext4" --grow --maxsize=71680 --size=1024 --name=root --vgname=fedora_patrycja

# System timezone
timezone Europe/Warsaw --utc

# Root password
rootpw --iscrypted --allow-ssh $y$j9T$O90kDhRkvBVHUADfU8jp5NEG$vkr1JDrarpJoffD60KULAt48lLAMTRRfRGyGwugTIS9
user --groups=wheel --name=pwojdylo --password=$y$j9T$X6q7QKbcl1w5szmt9pmMno7K$wJhR6jZbZXbHzWdPqaDwT9ZsXPZ0h6kAy7CzNPWnNj5 --iscrypted --gecos="Patrycja Wojdylo"

reboot
```

To zadanie pokazało, że Ansible ułatwia zarządzanie serwerami — można wszystko zrobić automatycznie, bez ręcznego klikania. Udało się połączyć zdalnie, zainstalować Dockera, uruchomić kontener i sprawdzić, że wszystko działa szybko i bez problemów.

## Instalacja nienadzorowana systemu Fedora

Zadanie polegało na automatycznej instalacji Fedory z użyciem pliku Kickstart.

Na początku utworzono maszynę wirtualną w VirtualBoxie i załadowano obraz ISO instalatora Fedora Server.


Aby pobrać plik konfiguracyjny z zainstalowanego już systemu użyłam polecenia `sudo cat /root/anaconda-ks.cfg`

Umieściłam plik kickstart na GitHub. 
Następnie wygenerowałam do niego link bezpośredni (raw) - `https://raw.githubusercontent.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/PW416345/anaconda-ks.cfg`, który skróciłam przy pomocy serwisu TinyURL, żeby łatwiej było go przepisać.

Skrócony link wykorzystałam podczas tworzenia nowej maszyny wirtualnej. W menu startowym instalatora, po naciśnięciu e, dopisałam go do linii poleceń w postaci:

`https://tinyurl.com/PW416345`


![alt text](<part4/Zrzut ekranu 2025-06-13 154111.png>)

Nacisnęłam `CTRL+X`, co uruchomiło instalator z wykorzystaniem mojego pliku Kickstart.

Instalacja zakończona.

![alt text](<part4/Zrzut ekranu 2025-06-13 163204.png>)












## Instalacja i uruchomienie Minikube

 Zainstalowałam Minikube, uruchomiłam klaster poleceniem `minikube start`, a jego stan zweryfikowałam za pomocą `minikube status`. 
 
 ![alt text](<part4/Zrzut ekranu 2025-06-13 172737.png>)


  Następnie uruchomiono Dashboard poleceniem `minikube dashboard` i sprawdzono stan działającego klastra.


![alt text](<Zrzut ekranu 2025-06-13 171240.png>)



 Aby rozpocząć ręczne uruchomienie poda, najpierw utworzyłam plik konfiguracyjny `nginx-pod.yaml`.
 
 ![alt text](<part4/Zrzut ekranu 2025-06-13 172332.png>)
 
 
 I uruchomiłam polecenia `kubectl apply -f nginx-pod.yaml`, `kubectl get pods`, `kubectl port-forward pod/nginx-pod 8088:8080`. 

  Aby zapewnić dostęp do środka klastra, utworzyłam tunel sieciowy za pomocą polecenia `minikube tunnel` Dzięki temu usługi i deployment działają poprawnie, a dostęp do nich jest łatwy i bezpieczny.
 

![alt text](<part5/Zrzut ekranu 2025-06-13 194400.png>)


![alt text](<part5/Zrzut ekranu 2025-06-13 194650.png>)


![alt text](<part5/Zrzut ekranu 2025-06-13 193938.png>)

![alt text](<part5/Zrzut ekranu 2025-06-13 194246.png>)
######################################


Wynik:

  ![alt text](<part4/Zrzut ekranu 2025-06-13 174616.png>)


Przygotowano plik `nginx-deployment.yaml`. Następnie uruchomiłam go poleceniem `kubectl apply -f nginx-deployment.yaml`, a poprawność działania sprawdziłam za pomocą polecen `kubectl get deployments` oraz `kubectl get pods`.


Wynik:

  ![alt text](<part4/Zrzut ekranu 2025-06-13 175120.png>)
  ![alt text](<part4/Zrzut ekranu 2025-06-13 175134.png>)


## Skalowanie Deploymentu

Ustawiłam liczbę działających replik najpierw na 1, a potem na 3, aby uruchomić więcej kopii aplikacji. Poprzez przegląarke mogłam szybko zweryfikować prawidłowe działanie.


![alt text](<part5/Zrzut ekranu 2025-06-13 200129.png>)

![alt text](<part5/Zrzut ekranu 2025-06-13 200406.png>)







## Błędna wersja obrazu

W pliku `nginx-deployment.yaml` zmieniłam obraz na nieistniejący.


![alt text](<part5/Zrzut ekranu 2025-06-13 201240.png>)


![alt text](<part5/Zrzut ekranu 2025-06-13 201438.png>)
Jak widać ErrImagePull wszystko wykonało się dobrze - nie znaleziono obrazu.

Aby przywrócić poprzednią, działającą wersję, użyłam polecenia rollback `kubectl rollout undo deployment nginx-deployment`

![alt text](<part5/Zrzut ekranu 2025-06-13 201738.png>)

Dzięki temu Kubernetes cofnął się do wcześniejszej poprawnej konfiguracji, a nowe pod’y zostały automatycznie uruchomione i działały prawidłowo.

## Strategia Recreate

Zmieniłąm strategię wdrażania na Recreate poleceniem `kubectl apply -f nginx-deployment.yaml`. Po ponownym zastosowaniu pliku stare pody zostały usunięte i zastąpione nowymi, które poprawnie się uruchomiły.


![alt text](<part5/Zrzut ekranu 2025-06-13 202526.png>)

Przy tej strategii nie ma przerwy w działaniu.

## Canary
To strategia, gdzie nowa wersja aplikacji jest najpierw wdrażana na małej części podów, aby przetestować ją przed pełnym uruchomieniem. 
W przeciwieństwie do Recreate, gdzie stare pody są usuwane od razu, Canary pozwala na stopniowe i bezpieczniejsze wprowadzenie zmian.

## Rollout
Zastosowałam rollout aby sprawdzić, czy deployment nginx-deployment uruchomił wszystkie repliki w czasie nie dłuższym niż 60 sekund.


![alt text](<part5/Zrzut ekranu 2025-06-13 203749.png>)

Strategie wdrożeń różnią się sposobem wymiany podów: Recreate usuwa wszystkie naraz, Canary wprowadza zmiany stopniowo, a Rolling Update aktualizuje je etapami, kontrolując dostępność aplikacji.