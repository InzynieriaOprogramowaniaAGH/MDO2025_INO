# Sprawozdanie (Zadania 8-10)

## Wprowadzenie

Celem zadania było utworzenie źródła i instalacji nienadzorowanej dla systemu operacyjnego hostującego nasze oprogramowanie i przeprowadzenie instalacji systemu, który po uruchomieniu rozpocznie hostowanie naszego programu.

## Zadanie 9: Pliki odpowiedzi dla wdroźeń nienadzorowanych

1. **Instalacja systemu Fedora i wyciągniecie pliku odpowiedzi:**

Zaczełam od instalacji nienadzorowanego systemu Fedora stosując instalator siedziowy (netinst). Następnie pobrałam plik odpowiedzi z ścieżki: `/root/anaconda-ks.cfg`. Plik wyglądał następująco:

``` bash
# Generated by Anaconda 41.35
# Generated by pykickstart v3.58
#version=DEVEL

# Keyboard layouts
keyboard --vckeymap=pl --xlayouts='pl'
# System language
lang pl_PL.UTF-8

# Network information
network  --bootproto=dhcp --device=enp0s8 --ipv6=auto --activate
network  --hostname=devops

%packages
@^server-product-environment

%end

# Run the Setup Agent on first boot
firstboot --enable

# Generated using Blivet version 3.11.0
ignoredisk --only-use=sda
# Partition clearing information
clearpart --none --initlabel
# Disk partitioning information
part /boot/efi --fstype="efi" --ondisk=sda --size=600 --fsoptions="umask=0077,shortname=winnt"
part /boot --fstype="ext4" --ondisk=sda --size=1024
part pv.48 --fstype="lvmpv" --ondisk=sda --size=13700
volgroup fedora_devops --pesize=4096 pv.48
logvol / --fstype="ext4" --grow --maxsize=71680 --size=1024 --name=root --vgname=fedora_devops

# System timezone
timezone Europe/Warsaw --utc

#Root password
rootpw --lock
user --groups=wheel --name=mpalewicz --password=$y$j9T$WRrPj8ruqRhT/Jdus.DBcaJL$pWYQ/nbxtIYHk/3kZA0ToBjINDoFvZ9DzSa0LxpTFJ5 --iscrypted --gecos="Małgorz"
```

Następnie przeszłam do dodania linijek kodu odpowiedzialnych za określenie źródła pakietów instalacyjnych używanych podczas instalacji systemu oraz linijke odpowiedzialną za dodanie dodatkowych repozytorium o nazwie `update` do instalatora.

```bash
url --mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-41&arch=aarch64
```
Wskazuje że instalator ma pobrać pakiety z jednego losowo wybranych mirrorów (serwerów lustrzanych Fedory), odpowiedniego dla `Fedory 41` i architektury `aarch64`.

```bash
repo --name=update --mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=updates-released-f41&arch=aarch64
```
Repozytorium to zawiera wydane aktualizacje do `Fedory 41`, dzięki temu instaltor od razu korzysta z najnowszych dostępnych pakietów, zamiast tylko tych, które byłu dostępne w momencie wydania obrazu ISO.

Dodatkowo została dodana opcja na końcu pliku `reboot` w celu zadbania o automatyczne ponowne uruchomienia na końcu instalacji.
 

2. **Automatyczna instalacja Fedory z użyciem pliku Kickstart:** 

Następnie wykonałam instalację systemu Fedora przy użyciu pliku Kickstart na nowo utworzonej maszynie wirtualnej. 

W tym celu, podczas pierwszego uruchomienia instalatora Fedory, wybrałam opcję `Install Fedora`, a następnie nacisnęłam klawisz `e`, aby edytować polecenie rozruchowe przed startem systemu.

W edytorze GRUB dopisałam do linii komendy adres URL prowadzący do pliku Kickstart, który wcześniej pobrałam z repozytorium GitHub, korzystając z opcji `Raw`, aby uzyskać bezpośredni link do pliku. Dopisany adres:

```bash
inst.ks=https://raw.githubusercontent.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/refs/heads/MP417124/INO/GCL02/MP417124/Sprawozdanie3/anaconda-ks.cfg
```

Po wprowadzeniu zmian zatwierdziłam je, naciskając kombinację klawiszy `Ctrl` + `X`, co spowodowało powrót do ekranu startowego i rozpoczęcie instalacji z wykorzystaniem wskazanego pliku Kickstart. Dzięki temu instalacja przebiegła w sposób automatyczny, zgodnie z zawartą w pliku konfiguracją.


## Zadanie 10: Wdrażanie na zarządzalne kontenery: Kubernetes (1)

Zaczełam od instalacji 

uzylam mpalewicz@devops:~$ minikube dashboard & zeby dzialalo w tle i nie zajmowalo terminala


Pobrałam instalator Minikube dla architektury aarch64 za pomocą komendy:

curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-latest.aarch64.rpm

Następnie zainstalowałam go poleceniem:

sudo rpm -Uvh minikube-latest.aarch64.rpm

Dzięki temu Minikube został poprawnie zainstalowany na moim systemie Fedora.


Uruchomiłam usługę Dockera poleceniem:

sudo systemctl start docker

a potem odpaliłam Minikube, żeby uruchomić klaster Kubernetes, używając:

minikube start

Dzięki temu Minikube zaczęło działać z wykorzystaniem Dockera jako sterownika.


Dodałam alias do pliku .bashrc, dzięki czemu polecenie kubectl automatycznie używa minikube kubectl --, wpisując:

echo 'alias kubectl="minikube kubectl --"' >> ~/.bashrc

Następnie załadowałam zmiany poleceniem:

source ~/.bashrc

i sprawdziłam działające podsy Kubernetes za pomocą:

kubectl get po -A

W ten sposób zweryfikowałam, że wszystkie kluczowe komponenty klastra Minikube działają poprawnie.



Włączyłam dodatek metrics-server w Minikube, wpisując:

minikube addons enable metrics-server

Dzięki temu klaster będzie mógł zbierać i udostępniać metryki zasobów, takich jak użycie CPU i pamięci, co jest przydatne do monitorowania i skalowania aplikacji.

Uruchomiłam dashboard Minikube w tle, wpisując:

minikube dashboard &

Dzięki temu interfejs webowy Minikube otworzył się i działał w tle, pozwalając mi na wygodne zarządzanie klastrem przez przeglądarkę, a jednocześnie mogłam dalej korzystać z terminala.



Sprawdzilam dzialaje wezly (workery)
poporzez kubectl get nodes.

 Uruchomiłam Dashboard, otwórz w przeglądarce, przedstaw łączność, link:

 http://127.0.0.1:32955/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/workloads?namespace=default

 uruchomilam konetener jako Pod 
 minikube kubectl -- run mojpod --image=nginx --port=80 --labels app=mojpod

 Pod dziala cop sprawdzilam poprzez terminal komenda kubectl get pods oraz popzrze dashboarc

 Wyprowadź port celem dotarcia do eksponowanej funkcjonalności poprzez komenda:
 kubectl port-forward pod/mojpod 8080:80

 Otworzylam przegladarke i wpisalam http://localhost:8080

 co pokazalo mi sie ekran powitalnuy ngix:

 oraz w zakladce Workloads > Pods :






 1. Zapisz wdrożenie jako plik YAML

Utwórz plik o nazwie np. nginx-deployment.yaml z taką zawartością:
apiVersion: apps/v1
kind: Deployment
metadata:
  name: moj-nginx
spec:
  replicas: 4
  selector:
    matchLabels:
      app: moj-nginx
  template:
    metadata:
      labels:
        app: moj-nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80

2. Przeprowadź próbne wdrożenie
kubectl apply -f nginx-deployment.yaml

3. Sprawdź status wdrożenia


kubectl rollout status deployment/moj-nginx

 


 Wyeksponuj deployment jako serwis typu ClusterIP lub NodePort (np. NodePort, żeby mieć dostęp spoza klastra):
 kubectl expose deployment moj-nginx --type=NodePort --port=80

 
  Sprawdź, jaki port NodePort został przydzielony (np. coś z zakresu 30000-32767):
  kubectl get svc moj-nginx

3. Przekieruj port lokalnie do tego serwisu:
  kubectl port-forward svc/moj-nginx 8080:80

Teraz Twoja aplikacja jest dostępna na http://localhost:8080

