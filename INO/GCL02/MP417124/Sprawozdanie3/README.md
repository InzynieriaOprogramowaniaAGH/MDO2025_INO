# Sprawozdanie (Zadania 8-10)

## Wprowadzenie

Celem zadania było utworzenie źródła i instalacji nienadzorowanej dla systemu operacyjnego hostującego nasze oprogramowanie i przeprowadzenie instalacji systemu, który po uruchomieniu rozpocznie hostowanie naszego programu.

## Zadanie 8: Automatyzacja i zdalne wykonywanie poleceń za pomocą Ansible

NA DEVOPS:
zaczelam od zainstalwoania 
sudo dnf install -y ansible        # instalacja ansible

ssh-copy-id ansible@ansible-target   # przesyłasz klucz SSH



## Zadanie 9: Pliki odpowiedzi dla wdroźeń nienadzorowanych

1. **Instalacja systemu Fedora i wyciągniecie pliku odpowiedzi:**

Zaczełam od instalacji nienadzorowanego systemu Fedora stosując instalator siedziowy (netinst). Następnie pobrałam plik odpowiedzi z ścieżki: `/root/anaconda-ks.cfg`. Plik wyglądał następująco:

``` bash
# Generated by Anaconda 41.35
# Generated by pykickstart v3.58
#version=DEVEL

# Keyboard layouts
keyboard --vckeymap=pl --xlayouts='pl'
# System language
lang pl_PL.UTF-8

# Network information
network  --bootproto=dhcp --device=enp0s8 --ipv6=auto --activate
network  --hostname=devops

%packages
@^server-product-environment

%end

# Run the Setup Agent on first boot
firstboot --enable

# Generated using Blivet version 3.11.0
ignoredisk --only-use=sda
# Partition clearing information
clearpart --none --initlabel
# Disk partitioning information
part /boot/efi --fstype="efi" --ondisk=sda --size=600 --fsoptions="umask=0077,shortname=winnt"
part /boot --fstype="ext4" --ondisk=sda --size=1024
part pv.48 --fstype="lvmpv" --ondisk=sda --size=13700
volgroup fedora_devops --pesize=4096 pv.48
logvol / --fstype="ext4" --grow --maxsize=71680 --size=1024 --name=root --vgname=fedora_devops

# System timezone
timezone Europe/Warsaw --utc

#Root password
rootpw --lock
user --groups=wheel --name=mpalewicz --password=$y$j9T$WRrPj8ruqRhT/Jdus.DBcaJL$pWYQ/nbxtIYHk/3kZA0ToBjINDoFvZ9DzSa0LxpTFJ5 --iscrypted --gecos="Małgorz"
```

Następnie przeszłam do dodania linijek kodu odpowiedzialnych za określenie źródła pakietów instalacyjnych używanych podczas instalacji systemu oraz linijke odpowiedzialną za dodanie dodatkowych repozytorium o nazwie `update` do instalatora.

```bash
url --mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-41&arch=aarch64
```
Wskazuje że instalator ma pobrać pakiety z jednego losowo wybranych mirrorów (serwerów lustrzanych Fedory), odpowiedniego dla `Fedory 41` i architektury `aarch64`.

```bash
repo --name=update --mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=updates-released-f41&arch=aarch64
```
Repozytorium to zawiera wydane aktualizacje do `Fedory 41`, dzięki temu instaltor od razu korzysta z najnowszych dostępnych pakietów, zamiast tylko tych, które byłu dostępne w momencie wydania obrazu ISO.

Dodatkowo została dodana opcja na końcu pliku `reboot` w celu zadbania o automatyczne ponowne uruchomienia na końcu instalacji.
 

2. **Automatyczna instalacja Fedory z użyciem pliku Kickstart:** 

Następnie wykonałam instalację systemu Fedora przy użyciu pliku Kickstart na nowo utworzonej maszynie wirtualnej. 

W tym celu, podczas pierwszego uruchomienia instalatora Fedory, wybrałam opcję `Install Fedora`, a następnie nacisnęłam klawisz `e`, aby edytować polecenie rozruchowe przed startem systemu.

W edytorze GRUB dopisałam do linii komendy adres URL prowadzący do pliku Kickstart, który wcześniej pobrałam z repozytorium GitHub, korzystając z opcji `Raw`, aby uzyskać bezpośredni link do pliku. Dopisany adres:

```bash
inst.ks=https://raw.githubusercontent.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/refs/heads/MP417124/INO/GCL02/MP417124/Sprawozdanie3/anaconda-ks.cfg
```

Po wprowadzeniu zmian zatwierdziłam je, naciskając kombinację klawiszy `Ctrl` + `X`, co spowodowało powrót do ekranu startowego i rozpoczęcie instalacji z wykorzystaniem wskazanego pliku Kickstart. Dzięki temu instalacja przebiegła w sposób automatyczny, zgodnie z zawartą w pliku konfiguracją.

![](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-06%20at%207.40.16%E2%80%AFPM.png)


## Zadanie 10: Wdrażanie na zarządzalne kontenery: Kubernetes (1)

1. **Instalacja i uruchomienie Minikube:**

Proces rozpoczęłam od pobrania i zainstalowania narzędzia Minikube, które pozwala na uruchomienie lokalnego klastra Kubernetes na moim systemie Fedora działającym na architekturze aarch64. Najpierw pobrałam odpowiedni instalator za pomocą polecenia:

``` 
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-latest.aarch64.rpm
```
Następnie zainstalowałam Minikube przy użyciu menedżera pakietów RPM:
``` 
sudo rpm -Uvh minikube-latest.aarch64.rpm
```
Dzięki temu Minikube zostało poprawnie zainstalowane w moim systemie:
![7.22.34](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%207.22.34%E2%80%AFPM.png)

2. **Konfiguracja środowiska i uruchomienie klastra:**

Po instalacji uruchomiłam usługę Docker, która jest wykorzystywana jako sterownik kontenerowy przez Minikube:
```
sudo systemctl start docker
```
Następnie rozpoczęłam pracę z Minikube, uruchamiając lokalny klaster Kubernetes:
```
minikube start
```
![7.24.25](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%207.24.25%E2%80%AFPM.png)
Uruchomienie klastra przebiegło pomyślnie, co potwierdziło działanie podstawowych komponentów Kubernetes.

Aby ułatwić korzystanie z narzędzia kubectl w kontekście Minikube, dodałam alias do pliku `~/.bashrc`:

```
echo 'alias kubectl="minikube kubectl --"' >> ~/.bashrc
source ~/.bashrc
```
![7.25.16](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%207.25.16%E2%80%AFPM.png)

Dzięki temu wszystkie polecenia kubectl automatycznie korzystają z kontekstu klastra Minikube, co upraszcza zarządzanie zasobami Kubernetes. 


3. **Weryfikacja działania klastra:**

Sprawdziłam działanie podstawowych komponentów i status podów systemowych komendą:

```
kubectl get po -A
```
Widoczne były wszystkie kluczowe komponenty systemowe, działające bez problemów, co potwierdziło, że klaster jest gotowy do wdrożeń. Włączyłam również przydatny dodatek metrics-server w Minikube, który pozwala na zbieranie i monitorowanie metryk zasobów klastra:

```
minikube addons enable metrics-server
```

![7.25.51](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%207.25.51%E2%80%AFPM.png)

4. **Uruchomienie interfejsu Kubernetes Dashboard:**

Aby ułatwić zarządzanie klastrem oraz podgląd stanu wdrożonych aplikacji, uruchomiłam graficzny dashboard Minikube:

```
minikube dashboard &
```

![7.26.16](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%207.26.16%E2%80%AFPM.png)
Dzięki uruchomieniu go w tle nie blokowałam terminala i mogłam jednocześnie wykonywać dalsze polecenia. Dashboard otworzył się w przeglądarce pod lokalnym adresem, umożliwiając wygodne zarządzanie zasobami Kubernetes.

link:  `http://127.0.0.1:32955/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/workloads?namespace=default`.


5. **Uruchomienie przykładowego kontenera jako Pod:**

Kolejnym krokiem było uruchomienie prostej aplikacji – serwera nginx – jako pojedynczego poda w klastrze:

```
minikube kubectl -- run mojpod --image=nginx --port=80 --labels app=mojpod
```
![7.36.02](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%207.36.02%E2%80%AFPM.png)

Sprawdziłam, czy pod działa poprawnie, za pomocą:
```
kubectl get pods
```
oraz w zakładce `Workloads` > `Pods` w Dashboardzie. Wszystko wskazywało na prawidłowe działanie.
![7.36.46](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%207.36.46%E2%80%AFPM.png)
![7.32.25](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%207.32.25%E2%80%AFPM.png)
![7.38.08](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%207.38.08%E2%80%AFPM.png)

6. **Uzyskanie dostępu do aplikacji:**

Aby uzyskać dostęp do serwera nginx działającego w podzie, wyprowadziłam port lokalny na port kontenera:
```
kubectl port-forward pod/mojpod 8080:80
```
![7.39.45](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%207.39.45%E2%80%AFPM.png)

Po wpisaniu w przeglądarce adresu: `http://localhost:8080` pojawiła się strona powitalna nginx, co potwierdziło, że połączenie z pod-em działa poprawnie.

![7.42.17](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%207.42.17%E2%80%AFPM.png)
![7.42.44](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%207.42.44%E2%80%AFPM.png)

7. **Tworzenie i wdrożenie Deploymentu z pliku YAML:**

Aby przejść od pojedynczego poda do bardziej produkcyjnego wdrożenia z replikami, przygotowałam plik `nginx-deployment.yaml` z definicją Deploymentu:


```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: moj-nginx
spec:
  replicas: 4
  selector:
    matchLabels:
      app: moj-nginx
  template:
    metadata:
      labels:
        app: moj-nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
```

Deployment ten definiuje cztery repliki aplikacji nginx, zapewniając tym samym wysoką dostępność i skalowalność. Wdrożyłam go komendą `kubectl apply -f nginx-deployment.yaml` i sprawdziłam status wdrożenia `kubectl rollout status deployment/moj-nginx`. Wszystkie repliki uruchomiły się poprawnie i były dostępne.

![8.08.45](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%208.08.45%E2%80%AFPM.png)
![8.12.04](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%208.12.04%E2%80%AFPM.png)

8. **Eksponowanie Deploymentu jako usługi:**

Aby umożliwić dostęp do aplikacji spoza klastra, wyeksponowałam Deployment jako serwis typu NodePort:

```
kubectl expose deployment moj-nginx --type=NodePort --port=80
```


Następnie sprawdziłam, jaki port został przypisany na węźle klastra poprzez `kubectl get svc moj-nginx` i na podstawie przydzielonego portu `NodePort` (z zakresu 30000-32767) wyprowadziłam port lokalny na port serwisu `kubectl port-forward svc/moj-nginx 8080:80`. Po otwarciu w przeglądarce adresu `http://localhost:8080` mogłam korzystać z aplikacji działającej w Kubernetes.

![8.15.42](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%208.15.42%E2%80%AFPM.png)
![8.18.42](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%208.18.42%E2%80%AFPM.png)
![8.19.24](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%208.19.24%E2%80%AFPM.png)
![8.23.44](https://github.com/InzynieriaOprogramowaniaAGH/MDO2025_INO/blob/MP417124/INO/GCL02/MP417124/Sprawozdanie3/Screenshots/Screenshot%202025-05-20%20at%208.23.44%E2%80%AFPM.png)

